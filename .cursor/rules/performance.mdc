---
globs: *.tsx,*.ts,*.js,*.jsx
alwaysApply: false
---
# 🚄 Performance Optimization Guidelines

パフォーマンス最適化は、優れたユーザー体験を提供し、SEOランキングを向上させ、コンバージョン率を高めるために不可欠です。TypeScriptを使用したReactアプリケーションにおいて、型安全性を保ちながら以下のガイドラインに従うことで、パフォーマンスを大幅に改善できます。

## TypeScript固有のパフォーマンス最適化

### 型定義の最適化

#### インターフェースと型の効率的な設計
- **軽量な型定義**: 過度に複雑な型定義はコンパイル時間に影響
- **型の再利用**: 共通の型定義を再利用しDRY原則を適用
- **適切な型の粒度**: 必要以上に厳密な型定義は避ける
- **型推論の活用**: TypeScriptの型推論を最大限活用し明示的な型注釈を最小化

#### ジェネリクスの適切な使用
- **制約付きジェネリクス**: `extends` キーワードによる型制約で型安全性とパフォーマンスを両立
- **デフォルト型パラメータ**: 頻繁に使用される型の組み合わせにデフォルト値を設定
- **型パラメータの最小化**: 必要最小限の型パラメータで複雑さを軽減

### コンパイル時の最適化

#### TSConfig設定の最適化
- **strict モード**: 厳密な型チェックによるランタイムエラーの事前防止
- **incremental コンパイル**: ビルド時間の短縮
- **skipLibCheck**: 不要なライブラリ型チェックをスキップ
- **target と module**: 適切なターゲット環境の設定

#### 型チェックパフォーマンス
- **型注釈の戦略的配置**: 推論困難な箇所のみに明示的な型注釈
- **as const アサーション**: リテラル型の活用によるより厳密な型推論
- **型ガードの活用**: ランタイム型チェックとコンパイル時型推論の組み合わせ

### ランタイム型安全性とパフォーマンス

#### バリデーションライブラリの選択
- **Zod**: スキーマ駆動開発とランタイム検証
- **Yup**: 軽量な検証ライブラリ
- **io-ts**: 関数型プログラミングアプローチ
- **パフォーマンス考慮**: 検証処理のオーバーヘッドと型安全性のバランス

#### 型安全なイベントハンドリング
- **厳密な型定義**: イベントハンドラーの型注釈による実行時エラー防止
- **カスタムフック型定義**: 再利用可能な型安全なフック
- **コールバック型の最適化**: 不必要な再レンダリングを防ぐ型定義

## Code Splitting（コード分割）

### 基本概念

コード分割は、本番用JavaScriptをより小さなファイルに分割して、アプリケーションの読み込み時間を最適化する手法です。この技術により、アプリケーションを部分的にダウンロードし、必要なコードのみを必要時に取得できます。

### 実装戦略

#### ルートレベルでの分割
- **推奨アプローチ**: ルートレベルでのコード分割を優先実装
- **利点**: 初期読み込みで必要最小限のコードのみをロード
- **遅延読み込み**: 追加部分は必要に応じて動的に取得

#### 過度な分割の回避
- **注意点**: 過度なコード分割はパフォーマンス低下を招く可能性
- **理由**: 多数のリクエストによるオーバーヘッド増加
- **推奨**: アプリケーションの重要部分に焦点を当てた戦略的分割

### ベストプラクティス
- 大きなライブラリやコンポーネントの遅延読み込み
- ユーザーインタラクションに基づく動的インポート
- 重要度に基づくコード優先順位付け
- バンドルサイズの継続的な監視

## Component and State Optimizations（コンポーネントと状態最適化）

### 状態管理の最適化

#### 状態分離の原則
- **避けるべき**: すべてを単一状態に集約
- **推奨**: 使用場所に応じた複数状態への分割
- **利点**: 不必要な再レンダリングの防止

#### 状態の近接配置
- **原則**: 状態を使用場所にできる限り近く配置
- **効果**: 依存しないコンポーネントの再レンダリング防止
- **実装**: ローカル状態の活用とprops drilling の最小化

#### 状態初期化の最適化
- **問題**: 高コストな計算の直接実行による毎回実行
- **解決策**: 状態初期化関数の使用
- **効果**: 一度のみの実行による計算コスト削減

### 高度な状態管理

#### アトミック更新ライブラリ
- **適用場面**: 多数の要素を同時に追跡する必要がある場合
- **推奨ライブラリ**: Jotai によるアトミック更新
- **利点**: 効率的な更新と依存関係管理

#### React Context の適切な使用
- **適用対象**: 低頻度データ（テーマ、ユーザーデータ、小規模ローカル状態）
- **中・高頻度データ**: use-context-selector ライブラリの検討
- **代替手段**: 状態の引き上げやコンポーネント構成の適切な活用

### スタイリング最適化

#### ランタイム vs ビルドタイム
- **ランタイム**: Emotion、Styled Components（動的生成）
- **ゼロランタイム**: Tailwind、Vanilla Extract、CSS Modules（ビルド時生成）
- **推奨**: 頻繁な更新が予想される場合はゼロランタイムソリューション

## Children Props Optimization（childrenプロップ最適化）

### 基本原則

childrenプロップは最も基本的で簡単なコンポーネント最適化手法です。適切に適用することで、多くの不必要な再レンダリングを排除できます。

### 最適化メカニズム

#### VDOM構造の分離
- **概念**: childrenとして渡されるJSXは分離されたVDOM構造を表現
- **効果**: 親コンポーネントによる再レンダリングが不要（不可能）
- **実装**: コンポーネント構成の見直しによる最適化

#### 実装パターン
- **問題のあるパターン**: 状態変更時の子コンポーネント再レンダリング
- **最適化パターン**: childrenプロップによる子コンポーネントの分離
- **効果**: 状態更新時の子コンポーネント再レンダリング防止

### 設計指針
- コンポーネント階層の見直し
- 状態とレンダリングの依存関係の最小化
- 再利用性とパフォーマンスのバランス

## Image Optimizations（画像最適化）

### 遅延読み込み

#### ビューポート外画像の最適化
- **実装**: Intersection Observer APIの活用
- **効果**: 初期読み込み時間の短縮
- **ユーザー体験**: スムーズなスクロール体験の提供

### 現代的な画像フォーマット

#### WEBP形式の採用
- **利点**: 従来フォーマットよりも高い圧縮率
- **互換性**: フォールバック画像の提供
- **実装**: pictureタグやWebP対応の確認

### レスポンシブ画像

#### srcset属性の活用
- **目的**: クライアント画面サイズに最適な画像の配信
- **実装**: 複数解像度画像の準備と適切な属性設定
- **効果**: 帯域幅使用量の最適化

### 追加最適化戦略
- 画像圧縮の自動化
- CDN（Content Delivery Network）の活用
- Progressive JPEG の使用
- クリティカル画像の優先読み込み

## Web Vitals（ウェブバイタル）

### 重要性

GoogleがWebサイトのインデックス作成時にWeb Vitalsを考慮するようになったため、これらのスコアの監視が重要になっています。

### 主要指標

#### Core Web Vitals
- **LCP（Largest Contentful Paint）**: 最大コンテンツの描画時間
- **FID（First Input Delay）**: 初回入力遅延
- **CLS（Cumulative Layout Shift）**:累積レイアウトシフト

#### 測定ツール
- **Lighthouse**: 包括的なパフォーマンス分析
- **PageSpeed Insights**: Googleの公式測定ツール
- **継続監視**: 定期的なスコア確認と改善

### 最適化戦略
- 重要なリソースの優先読み込み
- レイアウトシフトの最小化
- インタラクティブ性の早期確立
- サーバーレスポンス時間の最適化

## Data Prefetching（データプリフェッチング）

### 基本概念

ユーザーがページに移動する前にデータをプリフェッチすることで、アプリケーションのパフォーマンスを向上させることができます。

### 実装アプローチ

#### TanStack Query活用
- **メソッド**: `queryClient.prefetchQuery` の使用
- **タイミング**: ユーザー行動の予測に基づく事前読み込み
- **効果**: ページ遷移時のデータ読み込み時間短縮

#### 戦略的プリフェッチング
- **予測可能なナビゲーション**: 高確率で訪問されるページの事前読み込み
- **ユーザーインタラクション**: ホバーやフォーカス時のデータ準備
- **条件付きプリフェッチング**: ネットワーク状況やデバイス性能の考慮

### ベストプラクティス
- プリフェッチ対象の優先順位付け
- キャッシュ戦略との統合
- 不要なリクエストの回避
- ユーザーデータ使用量の考慮

## TypeScript型安全なメモ化とパフォーマンス最適化

### 型安全なReact.memo
- **適用対象**: プロップが変更されない限り再レンダリングを避けたいコンポーネント
- **TypeScript活用**: ジェネリクスを使用した型安全なコンポーネントラッピング
- **プロップ型の最適化**: プリミティブ型の使用による効率的な等価性チェック
- **注意点**: 参照の等価性チェックのオーバーヘッドと型推論の影響

#### 型安全な比較関数
- **カスタム比較関数**: 型注釈された比較ロジック
- **プロップの部分比較**: 必要な部分のみの型安全な比較
- **ディープ比較の回避**: 浅い比較での型安全性確保

### 型安全なuseMemoとuseCallback

#### useMemo の型安全な活用
- **明示的な型注釈**: 複雑な計算結果の型明示
- **型推論の活用**: TypeScriptによる自動型推論の最大化
- **依存配列の型安全性**: 型システムによる依存関係の検証
- **パフォーマンス指標**: 実際の計測に基づく適用判断

#### useCallback の型最適化
- **関数シグネチャの型定義**: 明確なパラメータと戻り値の型
- **イベントハンドラーの型安全性**: 厳密な型定義による実行時エラー防止
- **カリー化関数の型推論**: 部分適用とクロージャの型安全な実装
- **コールバック型の再利用**: 共通のコールバック型定義

### TypeScript依存配列の最適化

#### 型安全な依存関係管理
- **プリミティブ型の優先**: 参照型より安定したプリミティブ型の使用
- **as const アサーション**: 配列とオブジェクトのリテラル型固定
- **型ガードによる最適化**: 条件分岐での型絞り込み活用
- **デバッグ支援**: TypeScript型情報による依存関係の可視化

#### 型推論による最適化
- **自動推論の活用**: 明示的な型注釈を最小限に抑制
- **型の制約**: ジェネリクス制約による安全で効率的な型推論
- **コンパイル時チェック**: 型レベルでの依存関係検証

## TypeScriptバンドル最適化

### TypeScript対応Tree Shaking
- **概念**: 使用されないコードの自動除去
- **TypeScript設定**: ES6モジュールとcommonJS出力の最適化
- **型情報の活用**: TypeScriptコンパイラによるデッドコード検出
- **side-effect-free**: 副作用のない純粋関数とモジュールの設計

#### TypeScript固有の最適化
- **型のみのインポート**: `import type` による型情報のみの取得
- **const assertions**: `as const` によるリテラル型の最適化
- **enum の回避**: Union型やconst objectsによる軽量化
- **namespace の最小化**: モジュールシステムによる代替

### TypeScript動的インポート
- **型安全な動的インポート**: `import()` の戻り値型注釈
- **条件付き型読み込み**: コンポーネントとその型定義の遅延読み込み
- **React.lazy との組み合わせ**: 型安全なコンポーネント遅延読み込み
- **型推論の保持**: 動的インポート後の型情報維持

#### 実装パターン
- **型付きRouteコンポーネント**: 型安全なルート別コード分割
- **条件付き機能**: 機能フラグと型安全性の両立
- **プラットフォーム固有**: 環境別コードの型安全な分岐

### TypeScript依存関係最適化

#### 型定義ファイルの最適化
- **@types パッケージの選択的インストール**: 必要な型定義のみの導入
- **型定義の軽量化**: 過度に詳細な型定義の回避
- **自作型定義**: プロジェクト固有の軽量型定義作成
- **型の再エクスポート**: 共通型定義の一元管理

#### コンパイル設定による最適化
- **tsconfig.json の調整**: バンドルサイズに影響する設定の最適化
- **target の選択**: 実行環境に応じた適切なターゲット選択
- **module の設定**: Tree Shakingに最適なモジュール形式
- **declaration の管理**: 型定義ファイル生成の最適化

#### 依存関係の型監査
- **TypeScript型チェック**: 型レベルでの依存関係分析
- **バンドルアナライザー**: TypeScript出力の詳細分析
- **型推論キャッシュ**: 開発時の型チェック最適化
- **段階的型導入**: 既存プロジェクトでの段階的TypeScript化

## TypeScript総合的なパフォーマンス戦略

### 型安全な監視と測定
- **継続的監視**: 型安全なパフォーマンスメトリクス収集
- **A/Bテスト**: TypeScriptによる型安全なテスト実装
- **ユーザーフィードバック**: 型定義されたフィードバックデータの収集
- **型レベル分析**: TypeScript型情報を活用したパフォーマンス分析

#### TypeScript開発ツールの活用
- **型チェッカーの監視**: TypeScriptコンパイル時間の最適化
- **IDE統合**: TypeScript言語サーバーのパフォーマンス調整
- **型推論キャッシュ**: 開発時の応答性向上
- **バンドル分析**: TypeScript出力の詳細なパフォーマンス分析

### TypeScript段階的最適化

#### 型安全な優先順位付け
- **型レベル重要度**: TypeScript型システムによる影響度分析
- **段階的型導入**: 既存コードベースでの段階的TypeScript化
- **型安全性とパフォーマンス**: バランスの取れた最適化戦略
- **効果測定**: 型安全な指標による最適化効果の定量評価

#### 開発プロセス統合
- **型チェック自動化**: CI/CDパイプラインでの型安全性確保
- **プリコミットフック**: 型チェックとパフォーマンステストの統合
- **コードレビュー**: TypeScript観点でのパフォーマンスレビュー

### TypeScript対応チーム戦略

#### 型安全性文化の醸成
- **TypeScript教育**: チーム全体での型安全性理解向上
- **ベストプラクティス共有**: TypeScript固有のパフォーマンス知識共有
- **継続的改善**: 型安全性とパフォーマンスの両立を目指す文化
- **ツールチェーン最適化**: TypeScript開発環境の継続的改善

#### 品質保証との統合
- **型レベルテスト**: TypeScript型システムを活用したテスト戦略
- **パフォーマンス回帰**: 型安全な回帰テストの自動化
- **メトリクス収集**: TypeScript固有のパフォーマンス指標定義

この包括的なTypeScriptアプローチにより、型安全性を保ちながらユーザー体験を大幅に改善し、保守しやすく競争力のあるWebアプリケーションを構築することができます。