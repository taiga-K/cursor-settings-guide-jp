---
globs: *.tsx, *.jsx, *.ts, *.js
alwaysApply: false
---
# 🧱 Components And Styling Guidelines

効果的なコンポーネント設計とスタイリング戦略は、保守しやすく、スケーラブルで、パフォーマンスの高いReactアプリケーションの基盤となります。以下のガイドラインに従うことで、コードベースの品質と開発者体験を大幅に向上させることができます。

## Components Best Practices

### コロケーション（近接配置）の原則

**使用場所にできる限り近い場所に配置する**

コンポーネント、関数、スタイル、状態などを、それらが使用される場所にできる限り近い場所に配置してください。

#### 利点
- コードベースの可読性と理解性の向上
- アプリケーションパフォーマンスの改善
- 状態更新時の冗長な再レンダリングの削減
- 関連するコードの発見とメンテナンスの容易さ

#### 実装指針
- ローカル状態は可能な限りコンポーネント内に保持
- 特定の機能に関連するヘルパー関数は同じファイル内に配置
- コンポーネント固有のスタイルは同じディレクトリ内に配置

### 大きなコンポーネントとネストされたレンダリング関数を避ける

#### 問題のあるパターン
- コンポーネント内に複数のレンダリング関数を含める
- 単一コンポーネントに過度に多くの責任を持たせる
- 深くネストされた条件付きレンダリング

#### 推奨アプローチ
- UIの独立した単位を別のコンポーネントとして抽出
- 単一責任の原則に従った小さなコンポーネントの作成
- 明確な境界と責任を持つコンポーネント設計

#### 利点
- 保守性の大幅な向上
- テスタビリティの改善
- 再利用性の向上
- デバッグの容易さ

### コードスタイルの一貫性

#### 命名規則
- コンポーネント名はPascalCase（例：`UserProfile`、`NavigationMenu`）
- ファイル名の一貫性（component.tsx、component.stories.tsx、component.test.tsx）
- プロパティ名はcamelCase

#### ツール活用
- リンターとコードフォーマッターの適切な設定
- チーム内での設定の標準化

### プロパティ数の制限

#### 設計原則
- 過度に多くのプロパティを受け取るコンポーネントを避ける
- 関連するプロパティをオブジェクトとしてグループ化
- コンポジション技法の活用（children、slots）

#### 分割指針
- 5-7個以上のプロパティがある場合は分割を検討
- 機能ごとにコンポーネントを分離
- 高次コンポーネント（HOC）やカスタムフックの活用

### 共有コンポーネントのライブラリ化

#### 大規模プロジェクトでの抽象化
- 共有コンポーネントの体系的な管理
- アプリケーション全体での一貫性確保
- メンテナンス効率の向上

#### 実装戦略
- 重複パターンの特定と抽象化
- 間違った抽象化を避けるための段階的アプローチ
- 再利用可能なコンポーネントの設計

#### サードパーティコンポーネントのラッピング
- アプリケーションのニーズに合わせた適応
- 将来の変更への対応力向上
- 依存関係の管理とアップグレードの容易さ

## Component Libraries

### フル機能型コンポーネントライブラリ

完全にスタイル化されたコンポーネントを提供するライブラリ群：

#### Chakra UI
- **特徴**: 優れた開発者体験、高速プロトタイピング対応
- **利点**: デザインデフォルトの充実、カスタマイズ性、アクセシビリティ標準対応
- **適用場面**: 迅速な開発が必要なプロジェクト

#### Ant Design (AntD)
- **特徴**: 豊富なコンポーネント群
- **利点**: 管理画面の構築に最適
- **考慮点**: カスタムデザインへの適応に若干の困難

#### Material-UI (MUI)
- **特徴**: 最も人気の高いReactコンポーネントライブラリ
- **利点**: Material Designの実装、ヘッドレス使用も可能
- **適用場面**: Google Material Designに準拠したプロジェクト

#### Mantine
- **特徴**: モダンなコンポーネントライブラリ
- **利点**: 豊富なコンポーネントとフック、高いカスタマイズ性
- **適用場面**: 機能豊富なアプリケーション

### ヘッドレスコンポーネントライブラリ

スタイルが適用されていないコンポーネントを提供するライブラリ群：

#### 推奨ライブラリ
- **Radix UI**: 高品質なプリミティブコンポーネント
- **Headless UI**: Tailwind CSS チームによる開発
- **React Aria**: Adobe によるアクセシビリティ重視のライブラリ
- **Ark UI**: 現代的なヘッドレスコンポーネント
- **Reakit**: 軽量で柔軟なコンポーネント

#### 選択基準
- 特定のデザインシステムの実装が必要な場合
- 完全なカスタマイズ制御が必要な場合
- 既存のスタイリングソリューションとの統合

## Styling Solutions

### 主要なスタイリングオプション

#### Utility-First CSS
- **Tailwind CSS**: ユーティリティファーストのCSSフレームワーク
- **利点**: 高速開発、一貫性、小さなバンドルサイズ

#### CSS-in-JS ソリューション
- **Styled Components**: 人気の高いCSS-in-JSライブラリ
- **Emotion**: 高性能なCSS-in-JSライブラリ
- **利点**: 動的スタイリング、テーマ対応

#### Zero-Runtime ソリューション
- **Vanilla Extract**: 型安全なCSS-in-TypeScript
- **Panda CSS**: モダンなCSS-in-JSフレームワーク
- **利点**: ランタイムオーバーヘッドなし、型安全性

#### 伝統的なアプローチ
- **CSS Modules**: スコープ化されたCSS
- **利点**: 名前空間の衝突回避、既存CSSとの互換性

### React Server Components考慮事項

**重要な注意点**: React Server Componentsを使用する場合は、ランタイムでのスタイリングソリューションが不要なゼロランタイムソリューションを選択してください。

### コードベース型スタイリングソリューション

#### 新しいアプローチ
パッケージとしてインストールするのではなく、カスタマイズ可能なコードとして提供される：

- **ShadCN UI**: Radix UI + Tailwind CSS ベース
- **Park UI**: Ark UI + Panda CSS ベース

#### 利点
- 完全なカスタマイズ制御
- 依存関係の軽減
- プロジェクト固有のニーズへの適応

## Storybook

### コンポーネント開発・テストツール

#### 概要
Storybookは、コンポーネントを分離して開発・テストするための優れたツールです。アプリケーションで使用されるすべてのコンポーネントのカタログとして機能します。

#### 主要な利点
- **分離開発**: 他のコンポーネントに依存せずに開発
- **発見可能性**: チーム内でのコンポーネントの共有と発見
- **ドキュメント**: 自動的なコンポーネントドキュメント生成
- **テスト**: 視覚的回帰テストとインタラクションテスト

#### 活用場面
- デザインシステムの構築
- コンポーネントライブラリの開発
- チーム間でのコンポーネント共有
- 品質保証とテスト

### 実装のベストプラクティス

#### Story作成指針
- すべての主要なコンポーネントにStoryを作成
- 異なる状態とプロパティのバリエーションを網羅
- アクセシビリティテストの統合
- インタラクティブなコンポーネントのテスト

#### チーム連携
- デザイナーとの協力でデザインシステムの統一
- 開発者間でのコンポーネント共有
- 品質保証チームとの視覚的テスト

## 全体的な設計原則

### パフォーマンス考慮事項
- コンポーネントの遅延読み込み
- 適切なメモ化戦略
- バンドルサイズの最適化
- 再レンダリングの最小化

### アクセシビリティ
- セマンティックHTMLの使用
- ARIA属性の適切な実装
- キーボードナビゲーション対応
- スクリーンリーダー対応

### 保守性
- 明確な責任境界
- 適切な抽象化レベル
- テスタブルなコンポーネント設計
- ドキュメント化された設計決定

この包括的なアプローチにより、スケーラブルで保守しやすく、ユーザーフレンドリーなReactアプリケーションを構築することができます。